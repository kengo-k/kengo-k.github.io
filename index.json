[{"body":"","link":"https://just-plain-notes.blog/","section":"","tags":null,"title":""},{"body":"","link":"https://just-plain-notes.blog/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://just-plain-notes.blog/tags/programming/","section":"tags","tags":null,"title":"programming"},{"body":"","link":"https://just-plain-notes.blog/tags/rust/","section":"tags","tags":null,"title":"rust"},{"body":"","link":"https://just-plain-notes.blog/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"Rustの始めの一歩を踏み出す Rustは性能やメモリ安全性を目指して設計された言語うんぬん・・・とかこのブログで書いてもあんまり意味はないので省きます。Rustがどんな言語なのかは公式サイトかWikipediaを見てください(何かとGoと比較されているイメージありますがGoよりもはるかに難しい印象)。\n今回の記事ではRustの言語仕様については踏み込みません(次回以降にやります。多分)。\n今回やること：\nRustのインストール HelloWold ライブラリを追加 周辺ツールのインストール テストを実行 ビルド構成を理解する この記事の内容を理解することで、開発のスタートラインに立てることを目的とします。\nRustをインストールする 公式サイトに記載してあるcurlのインストールスクリプトを実行することでrustupというコマンドがインストールされます。これはRustのバージョンを管理して簡単に切り替えるものでasdfみたいなものです(asdfでRustをインストールすることもできます)。ちなみにMacの場合はHomebrewでもrustupをインストールできます。私はHomeberwを使いました。\nrustupをインストールしたらバージョンを指定してRustのインストールを行います。最新の安定版であるstableを指定します。\n$ rustup install stable\ninfo: syncing channel updates for \u0026#39;stable-x86_64-apple-darwin\u0026#39;\n...中略...\nstable-x86_64-apple-darwin installed - rustc 1.70.0 (90c541806 2023-05-31)\nインストールしたRustのバージョンをデフォルトに設定します。\n$ rustup default stable\ninfo: using existing install for \u0026#39;stable-x86_64-apple-darwin\u0026#39;\ninfo: default toolchain set to \u0026#39;stable-x86_64-apple-darwin\u0026#39;\nstable-x86_64-apple-darwin unchanged - rustc 1.70.0 (90c541806 2023-05-31)\n現在のRustのバージョンを確認します。\n$ rustc -V\nrustc 1.70.0 (90c541806 2023-05-31)\n現在インストールされているRustのバージョン一覧を確認します。\n$ rustup toolchain list\nstable-x86_64-apple-darwin (default)\nnightly-x86_64-apple-darwin\n1.68.2-x86_64-apple-darwin\n1.70.0-x86_64-apple-darwin\nプロジェクトルートにrust-toolchainファイルを作成しバージョン番号を記載しておくとプロジェクト内で利用するRustのバージョンを固定できます。\n# 現在のバージョンを確認\n$ rustc -V\nrustc 1.70.0 (90c541806 2023-05-31)\n# rust-toolchainファイルを作成\n$ echo 1.68.2 \u0026gt; rust-toolchain\n# 再度現在のバージョンを確認\n$ rustc -V\nrustc 1.68.2 (9eb3afe9e 2023-03-27)\nプロジェクトを作成する Rustにはrustcというソースファイルをコンパイルするコマンド(すでにバージョン番号の確認に使用しました)がありますが基本的にこのコマンドは使いません。通常はcargoというコマンドを使って開発を行います。cargoでビルド、テスト、ドキュメント生成、パッケージ公開など開発のライフサイクル全体をカバーできます。cargoを使用して新しいプロジェクトを作成するには次のコマンドを実行します。\n$ cargo new hello_world\nhello_worldという名前の新しいディレクトリに初期設定ファイルとサンプルコードが生成されます。\n$ tree hello_world\nhello_world\n|-- Cargo.toml\n|-- src\n|--main.rs\n2 directories, 2 files\nHelloWorldを実行する 新しいプロジェクトを作成すると、src/main.rsというファイルが作成されています。そこには既に\u0026quot;Hello, world!\u0026quot;と出力するサンプルコードが書かれています。\n1fn main() { 2 println!(\u0026#34;Hello, world!\u0026#34;); 3} 実行するには、ターミナルで以下のコマンドを実行します。\n$ cargo run\n正常に実行されるとターミナルに\u0026quot;Hello, world!\u0026quot;と表示されます。\nCargo.tomlファイルの簡単な解説 プロジェクトルートにCargo.tomlというファイルがあります。これはプロジェクトの設定と依存関係を管理するためのファイルです。プロジェクト生成時のデフォルトの内容は以下のようになっています。\n[package]\nname = \u0026#34;hello_world\u0026#34;\nversion = \u0026#34;0.1.0\u0026#34;\nedition = \u0026#34;2021\u0026#34;\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n[dependencies]\npackageセクションには、パッケージの名前、バージョン、エディションが記載されます。dependenciesセクションにはプロジェクトが依存するライブラリを記述します。実際の開発では間違いなくライブラリを使用するため、依存ライブラリを設定する方法を見ておきます。例えばRustの構造体をJSON形式に変換するためのライブラリ「serde」および「serde_json」を使いたい場合、dependenciesセクションに以下のように追記します。\n[dependencies]\nserde = { version = \u0026#34;1.0.126\u0026#34;, features = [\u0026#34;derive\u0026#34;] }\nserde_json = \u0026#34;1.0.64\u0026#34;\n追加したライブラリを使うコードを書いてみる main.rsを以下のように書き換えます。\n1use serde::{Serialize, Deserialize}; 2use serde_json::Result; 3 4#[derive(Serialize, Deserialize)] 5struct Person { 6 name: String, 7 age: i32, 8} 9 10fn main() -\u0026gt; Result\u0026lt;()\u0026gt; { 11 let john = Person { name: String::from(\u0026#34;John\u0026#34;), age: 30 }; 12 let john_json = serde_json::to_string(\u0026amp;john)?; 13 println!(\u0026#34;{}\u0026#34;, john_json); 14 Ok(()) 15} これによりjohnというPersonオブジェクトがJSON形式に変換され、その結果が出力されます。\n$ cargo run\n{\u0026#34;name\u0026#34;:\u0026#34;John\u0026#34;,\u0026#34;age\u0026#34;:30}\ncargo-editを使って依存ライブラリを登録する 他の言語、例えばNodeJSではnpm installコマンドによって自動的にpackage.jsonに依存ライブラリを追加できます。しかしRustにはデフォルトでnpm installに相当するコマンドがないため手動でCargo.tomlを編集する必要があります。これは少しだけ面倒です。\ncargo-editコマンドを使うことでnpm installと同様にCargo.tomlを直接編集せずに依存ライブラリを追加・削除・更新できます。以下のコマンドでcargo-editをインストールします。\n$ cargo install cargo-edit\ncargo addコマンドでCargo.tomlを直接編集せずに依存ライブラリを追加できます。\n$ cargo add \u0026lt;ライブラリ名\u0026gt;\nコマンド実行後、Cargo.tomlのdependenciesセクションに指定したライブラリが自動的に追加されます。\ncargo-editのインストールに失敗する場合 私の環境(MacOSX)ではcargo-editのインストール時にエラーが発生しました。コンソールの出力には、\nerror: failed to run custom build command for `openssl-sys v0.9.88`\nというエラーが表示されました。この場合はbrew install opensslによりopensslをインストール後、再度インストールを行うと正常にインストールできました。\ncargo-testでテストを実行する 上で実装した構造体をJSONに変換するプログラムのテストを書いてみます。まずはJSON変換のロジックを関数として切り出してテストしやすくします。次のように修正します。\n1fn person_to_json(person: \u0026amp;Person) -\u0026gt; Result\u0026lt;String\u0026gt; { 2 let json = serde_json::to_string(person)?; 3 Ok(json) 4} 5 6fn main() -\u0026gt; Result\u0026lt;()\u0026gt; { 7 let john = Person { name: String::from(\u0026#34;John\u0026#34;), age: 30 }; 8 let john_json = person_to_json(\u0026amp;john)?; 9 println!(\u0026#34;{}\u0026#34;, john_json); 10 Ok(()) 11} person_to_json関数を作成してmain関数から呼び出すように修正しました。つづいて関数のテストを書きます。main.rsにさらに次のコードを追加します。\n1#[cfg(test)] 2mod tests { 3 use super::*; 4 5 #[test] 6 fn test_person_to_json() { 7 let alice = Person { name: String::from(\u0026#34;Alice\u0026#34;), age: 25 }; 8 let json = person_to_json(\u0026amp;alice); 9 assert!(json.is_ok()); 10 assert_eq!(json.unwrap(), \u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;Alice\\\u0026#34;,\\\u0026#34;age\\\u0026#34;:25}\u0026#34;); 11 } 12} そしてcargo testコマンドを実行することでテストを実行します。\n$ cargo test\nFinished test [unoptimized \u0026#43; debuginfo] target(s) in 0.02s\nRunning unittests src/main.rs\nrunning 1 test\ntest tests::test_person_to_json ... ok\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n今回書いたテストでは、関数を定義したソースファイル内にテストコードを記述しました。この形式は「ユニットテスト」と呼ばれる形式になります。他にも独立したテストケースファイルを作成する「インテグレーションテスト」やコメントにテストコードを記載してテストを実行できる「ドキュメンテーションテスト」も作成できます。ここでは割愛しますが、こちらのリポジトリにサンプルコードがあるので確認してみてください。\ncargo-watchでソースを修正したタイミングで自動でビルドする ソースコードを修正するたびにターミナルに戻ってcargo buildを実行するのは手間なのでファイルを保存したときに自動でビルドを実行できるようにします。これを実現するコマンドがcargo-watchになります。以下のコマンドでインストールを行います。\n$ cargo install cargo-watch\ncargo-watchのインストールに失敗する場合 私の環境(MacOSX)ではcargo-watch のインストール時にエラーが発生しました。下記のエラーが表示されていました。\n$ cargo install cargo-watch\nUpdating crates.io index\nInstalling cargo-watch v8.4.0\n(...中略...)\nerror: failed to run custom build command for `mac-notification-sys v0.5.6` mac-notification-sys v0.5.6のビルドで失敗しているようなのですが、原因がわからないので解決できませんでした。そのためcargo installコマンドにバージョン指定するオプションを追加して古いcargo-watchをインストールすることで対応しました。\n$ cargo install cargo-watch --version 7.8.1\nインストールしたバージョンをどうやって捜したかについてですが、cargoコマンドにはインストール可能なバージョンを一覧表示するサブコマンドが見当たらなかったためGitHubリポジトリのリリース一覧を確認しました。とりあえず一つ前のメジャーバージョンの最新を使用しました。\ncargo-watchのインストール後は以下のようにコマンドを実行します。\n$ cargo watch -x build\n\u0026quot;-x test\u0026quot;や\u0026quot;-x run\u0026quot;なども実行できます。\nCargo.tomlとクレートについて Rustについての解説ページを見ていると「クレート」という言葉が出てきます。見慣れない言葉ですが、どういう意味でしょうか。英単語としては「木箱」「かご」といった意味を持つようです。RustにおけるクレートとはRustプログラムのビルド単位となるものです。main.rsをビルドするとバイナリファイルが作成されます。つまりmain.rsはクレートです。この場合はバイナリクレートとなります。\nCargo.tomlにはクレートの設定を記述します。Cargo.tomlには複数のバイナリクレートと最大で1つのライブラリクレートを含めることができます。この記事の前半でCargo.tomlの内容を確認しましたが、下記のようになっていました。\n[package]\nname = \u0026#34;hello_world\u0026#34;\nversion = \u0026#34;0.1.0\u0026#34;\nedition = \u0026#34;2021\u0026#34;\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n[dependencies]\nこのCargo.tomlにはクレートに関する設定は含まれていません。その場合は、デフォルトでmain.rsが定義されているものと見なされます。このファイルをビルドすると[package]セクションのnameで指定されたバイナリファイルが生成されます。つまりmain.rsはRustによって規定された特別な意味を持つファイル名です(同様にライブラリクレートのデフォルトのファイル名はlib.rsとなります)。\n明示的にクレートの設定を追加することで、main.rsではない名前を使用したり、複数のバイナリクレートを定義できます。例えばsrc/main2.rsをバイナリクレートとして登録するには次のようにCargo.tomlを修正します。\n[package]\nname = \u0026#34;hello_world\u0026#34;\nversion = \u0026#34;0.1.0\u0026#34;\nedition = \u0026#34;2021\u0026#34;\n[[bin]]\nname = \u0026#34;main2\u0026#34;\npath = \u0026#34;src/main2.rs\u0026#34;\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n[dependencies]\nsrc/main.rsとsrc/main2.rsが同時に存在する状態でcargo buildを実行すると、src/main.rsからhello_worldというバイナリを、src/main2.rsからmain2というバイナリをそれぞれ生成します。またsrc/binディレクトリ配下にmain関数を持つRustのソースファイルを配置した場合、Cargo.tomlに記述しなくても自動的にバイナリクレートとして扱われます。その場合、生成されるバイナリファイル名はソースファイルから拡張子を除いたものになります。\nこちらのリポジトリにサンプルコードがあるので確認してみてください。ライブラリクレートの例もあります。\nモジュールについて Runtにはモジュールと呼ばれる概念もあります。モジュールはクレート内に名前空間を導入するために使います。以下のコードをみてください。\n1pub mod my_mod { 2 pub fn hello() { 3 println!(\u0026#34;Hello, World!!\u0026#34;); 4 } 5} 6 7fn main() { 8 my_mod::hello(); 9} main.rs内にインラインにモジュールmy_modを定義し、モジュール内の関数を呼び出しています。もちろん別ファイルとして切り出すことができます。my_mod.rsという名前で以下の内容を作成します。\n1pub fn hello() { 2 println!(\u0026#34;Hello, World!!\u0026#34;); 3} main.rs内で定義した関数をそのまま移植しただけです。特にモジュール名の宣言は必要はありません。ファイル名がそのままモジュール名として扱われます。このモジュールを使うにはmain.rsを次のように修正します。\n1mod my_mod; // 同ディレクトリにあるmy_mod.rsを参照します 2 3fn main() { 4 my_mod::hello(); 5} mod宣言をすると、指定したモジュール内にある要素にアクセスできますが、基本的に\u0026quot;モジュール名::名前\u0026quot;のようにフルパスで指定する必要があります。今回のように短いパスの場合は問題はありませんが、モジュールがネストした場合は冗長になります。その場合はuseを使うことで短い名前でアクセスできるようになります。次のようにmain.rsを修正します。\n1mod my_mod; 2 3use my_mod::hello; // 追記 4 5fn main() { 6 hello(); // useしたのでモジュールパスを省略できる 7} プログラムが大きくなると機能別にディレクトリを分けたくなります。これから実際にモジュールをディレクトリに分割してみます。\nモジュールを分割するには二つの方式があります。2018エディションから使用できる新しい形式と、それ以前の古い形式です。基本的には新しいエディションを使っている場合は新形式だけを使えば良いですが、どちらの書き方も理解しておく必要はあるため、両方とも紹介しておきます。\n新形式(2018エディションから) 親モジュール名と同名のディレクトリを作成し、ディレクトリ内にサブモジュールを作成します。この場合は既にmy_mod.rsがあるので、同名のディレクトリmy_modを作成します。my_modディレクトリ内に以下の内容でfoo.rsを作成します。\n1pub fn hello() { 2 println!(\u0026#34;Hello, foo!!\u0026#34;); 3} そしてmy_mod.rs内にfooモジュールを公開する設定を追記します。\n1pub mod foo; // 追記。my_mod/foo.rsを参照する 2 3pub fn hello() { 4 println!(\u0026#34;Hello, World!!!!\u0026#34;); 5} 最後に、main.rsからfooモジュールにある関数の呼び出しを追加します。\n1mod my_mod; 2 3use my_mod::hello; 4 5fn main() { 6 hello(); 7 my_mod::foo::hello(); // 追記 8} cargo runを実行し、以下の出力が表示されればOKです。\nHello, World!!\nHello, foo!!\n旧形式 新形式ではモジュールmy_mod.rsが存在する時に、my_modモジュール内にサブモジュールを作成する方法として、親モジュールと同名のディレクトリmy_modを作成し、ディレクトリ配下にサブモジュールを作成しました。旧形式の場合は親モジュールのディレクトリのみが存在し、ディレクトリ内に親モジュールの内容を定義するmod.rsという名前のファイルを作成します。my_modモジュール内に旧形式でbarモジュールを、そしてbarモジュールのサブモジュールbazを作成します。\nmy_mod/bar/baz.rs:\n1pub fn hello() { 2 println!(\u0026#34;Hello, baz!!\u0026#34;); 3} my_mod/bar/mod.rs:\n1pub mod baz; そしてmy_mod.rsにモジュールbarを公開するように追記します。\n1pub mod foo; 2pub mod bar; // 追記 3 4pub fn hello() { 5 println!(\u0026#34;Hello, World!!\u0026#34;); 6} 最後にmain.rsにbazの呼び出しを追加します。\n1mod my_mod; 2 3use my_mod::hello; 4 5fn main() { 6 hello(); 7 my_mod::foo::hello(); 8 my_mod::bar::baz::hello(); // 追記 9} 下記の出力が表示されれば成功です。\nHello, World!!\nHello, foo!!\nHello, baz!!\nディレクトリ構成は以下のとおりです。\nsrc\n|-- main.rs\n|-- my_mod\n|　|-- bar\n|　|　|-- baz.rs\n|　|　|-- mod.rs\n|　|-- foo.rs\n|-- my_mod.rs\n今回は例のためにわざと新形式と旧形式を混ぜて使っていますが2018以降の新しいエディションを使う場合、特別な理由がない限りは新形式だけを使うようにしましょう(わざわざ混ぜる意味はないので)。\nおわりに 以上で今回の記事、RustでHelloWorld+αは終了となります。いかがでしたでしょうか。Rust自体のコード解説はほとんどしてこなかったので、さっぱりわからなかった方もいるかもしれません。でも安心してください(？)、私もほとんどわかっていません。今は雰囲気レベルで何となく理解できれば良いと思います。何らかのプログラミング経験があればわかるはず、と信じています。今回の記事がRustの学習を始める方の役に立てば幸いです。\n","link":"https://just-plain-notes.blog/post/2023/06/beginning-rust/","section":"post","tags":["rust","programming"],"title":"そろそろRustデビュー目指すか・・・開発環境を作ってHelloWorld +αする！"},{"body":" フリーランスでプログラマをやっております。歴は結構長いです。 自分でも言うのもどうかと思いますが、中の上(いや中の中?)くらいのスキルのプログラマかなと思ってます。 もっと強気に行きたい気持ちもあるけど実際のところそんなものです。 いわゆる業務系のプログラム開発であれば大体のことはできる(はずだ)。 フロントエンドもバックエンドもやります(あんまりフルスタックというワードを使いたくないです)。インフラ系は苦手です。 最近はAWSくらい触れて当たり前だよねと言う空気を感じてるのでudemyを見て勉強中です。 今一番関心があるのはコンテナ関連の技術とAI。\nSKILLS Languages, Operating Systems \u0026amp; Tools Java JavaScript TypeScrpt Scala Golang linux git bash 新卒入社から長いことJava/JavaScriptをやっていました。JavaはJava8が出る直前まで使っていました (ので最新のJavaのことはもう何も知らない)。JavaScriptは現在進行形で使い続けています(メインはTypeScriptになりましたが)。\nScalaは1年ほど経験。難しい。当時はそれなりに書けていたと自認してますが久しぶりにコードを見た時にほとんど読めなくなっていた・・・。 直近ではGo言語をメインで実装しています。Goは誰でも使える言語ではあると思うけど表現力が物足りなくてやや微妙だと思っている。 今はRustへ移行したいと思っている。\n関数型言語に興味あり。フロントエンド開発でElmを使ってみたい。\nDatabase Oracle SQLServer MySQL PostgreSQL Oracle/SQLServerはそれなりの期間触ってきました。SQLの実行計画みてパフォーマンスチューニングしたり、 PL/SQL＆Transact-SQLでストアドプロシージャ書いたりとか。\n最近はSQLを書く機会はほとんどない。NoSQLは未経験。\nContainers \u0026amp; Cloud Docker \u0026amp; Docker Compose ローカル開発環境を自分で構築することくらいはできる。というかそれくらいしかできない。Kubernatesを覚えたい。\n","link":"https://just-plain-notes.blog/about/","section":"","tags":null,"title":"私について"},{"body":"","link":"https://just-plain-notes.blog/tags/aws/","section":"tags","tags":null,"title":"aws"},{"body":"","link":"https://just-plain-notes.blog/tags/cloud/","section":"tags","tags":null,"title":"cloud"},{"body":"今回やること これまで、個人でAWSを触るときは何も気にせずルートアカウントを使っていました。 本記事では最低限の権限を持つIAMユーザとロールを作成し、ルートアカウントを使わずに作業ができる環境を構築することを目指します。\n注意事項 実務でAWSの権限管理をしたことがない素人が記事を書いております。 もちろん記事は実際に動作確認などを行なった上で掲載していますが、AWS運用のベストプラクティスに従っていない内容を含んでいる可能性もあります。 IAMを利用した権限管理の基本的な作業フローを把握するためのもの、という程度の認識で見てもらえると助かります(言い訳)。\nルートアカウントにMFAを設定する 本題に入る前に、最初にルートアカウントにMFA(マルチファクタ認証)を設定します。 MFAはパスワードだけではなく追加の認証要素（例えば携帯電話に送られたワンタイムパスワードなど）を必要とする認証方法です。 MFAを設定することで、パスワードが盗まれたとしても攻撃者がアカウントにアクセスするのを防ぐことができます。\n次の手順でMFAを設定します。\nAWSのルートアカウントでAWSマネジメントコンソールにログインします。 画面右上のアカウント名の部分をクリックしてメニューを表示し、「セキュリティ認証情報」をクリックします。 「セキュリティ認証情報(ルートユーザ)」画面の「MFAを割り当てる」ボタンをクリックします。 「MFAデバイスを選択」画面にて必要な情報を入力します。\n「デバイス名」に任意の名前を設定します。ここではgoogle-authenticatorと設定しました。 「MFAデバイス」に「認証アプリケーション」を選択します。 「次へ」をクリックします。 デバイスの設定画面が開きます。\n表示されたQRコードを読み取るための認証アプリケーションをインストールします。\nここではChrome拡張機能の「Authenticator」を使用します。\n↑をインストールします。\nAuthenticatorを使用して先ほどのQRコードを読み取ります。\nChromeのアドレスバーの右にあるQRコードのアイコンをクリックします。 表示されたウィンドウ内の赤枠で囲ったボタンをクリックします。 範囲選択するモードになるのでQRコードを選択し読み取ります。 QRコードの読み取りに成功すると次のダイアログが表示されます。\nAuthenticatorを使用してデバイスの設定画面に二つのMFAコードを入力します。\nMFAコードを入力したら「MFAを追加」ボタンをクリックします。\nセキュリティ認証情報(ルートユーザー)画面に戻ります。 多要素認証(MFA)一覧に新しいデバイスが追加されていればOKです。\nルートアカウントのアクセスキーを削除する ルートアカウントにアクセスキーを設定している場合は削除します。 ルートアカウントは全てのリソースにアクセスできる特権を持つため、アクスセスキーの盗難や操作ミスによる事故が起きた時の被害を最小限にとどめるため、ルートアカウントはアクセスキーを持たないようにします。\nルートアカウントにアクセスキーが設定されているとIAMダッシュボードに警告が表示されます。\n「アクセスキーを管理」から登録されているアクセスキーを削除します。\n700日以上前からルートアカウントのアクセスキーがずっと設定されていたようです（恐ろしい)。 アクセスキーの削除後に警告が消えていればOKです。\nルートアカウントに対して最低限の設定をすることができました。 本記事の以降に紹介する設定を行うことで、IAMユーザ(およびロール)のみで日常的な作業を完結できるようになるため、 ルートアカウントを使用する機会を極力減らすことができるようになります。\nということでここからが本題になります。\n作成するリソースを検討する 作業の手順としては、最初にポリシーを作成し、次に作成したポリシーをユーザー/グループ/ロールにアタッチしていくことになります。 まずは作成すべきポリシーを洗い出すために、どのようなユーザ/グループ/ロールが必要になるかを検討します。\nユーザの検討 開発者用ユーザdev-userを作成します。dev-userには直接ポリシーを設定しません。 代わりに必要なポリシーを設定したグループを作成し、dev-userはそのグループに所属します。ユーザーに直接ポリシーを設定することも可能ですが、 ユーザが増えた場合、個々のユーザに対し都度ポリシーを設定する作業が必要になります。\nグループの検討 下記の二つのグループを作成します。\ndeveloper developer-base developerグループは開発対象の具体的なサービス(今回はLambdaとS3を想定)に関するポリシーを設定します。\ndeveloper-baseグループには開発全般で必要となる基本的なポリシーを設定します。具体的には、\nMFAを設定できる アクセスキーを作成できる ロールの引き受けができる ロールの移譲ができる ロールを一覧表示できる 上記の操作を実行できるようにします。1\u0026amp;2は特に解説する必要がないと思いますが、3〜5については軽く触れておきます。\nまず「ロールの引き受け」とはマネージメントコンソール画面での「ロールの切り替え」ボタンのクリックに相当するものです。 本番環境のリソースにアクセスする際に、一時的に本番用ロールに切り替えて作業をした経験がある方は多いと思います。英語の表現的には ロールをAssumeする(引き受ける)、と言うようです。\n次に「ロールの委譲」についてですが、文字通りの意味でロールを渡すことができるようになります。 これが必要になる例としてはLambda関数の作成時があります。 例えばLambda関数がS3にアクセスするためには、S3にアクセスするためのロールをLambdaに渡さなければなりません。 ロールを渡すためにはLambda関数を作成するユーザが「ロールを委譲」する権限を持たなければなりません。\n最後に「ロールの一覧表示」ですが、こちらもLambda関数の作成時を例にします。 マネージメントコンソールからLambda関数を作成する時にLambdaに渡すロールをロール一覧の中から選択できます。 その際にロールの一覧表示をする権限が必要となります。\nロールの検討 下記の二つのロールを作成します。\nadmin exec-lambda adminロールは開発以外の管理系の作業を行うためのロールです。ロールではなく別ユーザを用意しても構いません。 ただし、結局操作するのは自分ひとりしかいないため、今回はロールにすることにしました。 別ユーザにしてしまうとログアウトして入り直すという作業が必要になるので手間が増えるためです。\nexec-lambdaロールはLambda実行時のロールです。 Lambda関数の作成時にLambdaに渡します。 S3へアクセスする最小の権限を設定します。\nポリシーを作成する 必要なポリシーの洗い出しができたので実際にポリシーを作成していきます。 そもそもポリシーとはなんぞやですが、ポリシーは「あるリソースに対する操作を許可するか拒否するか」を記述したもので以下のような形式を持つJSONです。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: \u0026#34;lambda:*\u0026#34;, 7 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:lambda:ap-northeast-1:\u0026lt;account-id\u0026gt;:function:\u0026lt;function-name\u0026gt;\u0026#34; 8 } 9 ] 10} 作成したポリシーはユーザ/グループ/ロールに付与(アタッチ)することで機能します。\nActionには操作を指定します。上記の例ではLambdaに関連するすべての操作(lambda:*)を意味します。 Lambdaの場合、関数の作成/実行/削除/etcといったことを表します。そしてEffectでその操作を許可(Allow)するか拒否(Deny)するかを指定します。\nResourceにはActionで指定した操作の対象となるリソース名を指定します。Resourceに指定するリソースの種類はActionに対応するものになります。つまりActionがS3であればバケット名、LambdaであればFunction名という感じです。リソース名の記述にはARNという形式を使います。ARNは一般的に以下のような形式を持ちます：\narn:aws:\u0026lt;サービス名\u0026gt;:\u0026lt;リージョン名\u0026gt;:\u0026lt;アカウントID\u0026gt;:・・・\n実際には個々のサービスによって「:」で区切られた要素の数や種類は異なります。例えばS3バケットのARNは\narn:aws:s3:::\u0026lt;バケット名\u0026gt;\nとなり、リージョン名やアカウントIDは指定しません。これはS3のバケット名が全世界で一意になる必要があるからです。\nそれでは実際にポリシーを実装していきます。\nenable-mfa MFAを設定可能にするポリシーです。ルートアカウントだけでなくログイン操作をする全てのユーザはMFAを設定するべきです。 そのため、これから作成するユーザもMFAを設定可能にしておきます。\nIAMの画面を開き「ポリシー」を選択します。\nポリシ一の一覧画面から「ポリシーを作成」ボタンをクリックします。\nポリシー作成画面が開きます。「JSON」をクリックしJSONエディターから直接JSONを編集します。\nJSONエディターに以下の内容のJSONを設定します。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: [ 7 \u0026#34;iam:CreateVirtualMFADevice\u0026#34;, 8 \u0026#34;iam:DeleteVirtualMFADevice\u0026#34;, 9 \u0026#34;iam:ListVirtualMFADevices\u0026#34; 10 ], 11 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;account-id\u0026gt;:mfa/*\u0026#34; 12 }, 13 { 14 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 15 \u0026#34;Action\u0026#34;: [ 16 \u0026#34;iam:EnableMFADevice\u0026#34;, 17 \u0026#34;iam:ResyncMFADevice\u0026#34;, 18 \u0026#34;iam:ListMFADevices\u0026#34; 19 ], 20 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;account-id\u0026gt;:user/${aws:username}\u0026#34; 21 }, 22 { 23 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 24 \u0026#34;Action\u0026#34;: \u0026#34;iam:DeactivateMFADevice\u0026#34;, 25 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;account-id\u0026gt;:user/${aws:username}\u0026#34;, 26 \u0026#34;Condition\u0026#34;: { 27 \u0026#34;BoolIfExists\u0026#34;: { 28 \u0026#34;aws:MultiFactorAuthPresent\u0026#34;: \u0026#34;true\u0026#34; 29 } 30 } 31 } 32 ] 33} 個々のActionで記述した厳密な意味はほとんど理解していません(ごめんなさい)。基本的にChatGPTに書いてもらっています。 「名前を見た感じMFAデバイスを削除したり一覧表示したりするのに必要なものだろうなー」くらいの感覚です(今はそれで十分だろうと思ってます)。\n上記JSONの\u0026lt;account-id\u0026gt;は、自分が使用している実際のアカウントIDで置き換えてください。JSONの編集後、JSONエディタの下部にある「次へ」をクリックし確認画面を表示します。ポリシー名を入力し、画面下部の「ポリシーの作成」ボタンをクリックします。\n以上の操作でポリシーが作成されます。\nenable-accesskey アクセスキーの作成を可能にします。操作手順については、先ほどと同様ですので、以降はJSONのみを掲載します。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: [ 7 \u0026#34;iam:CreateAccessKey\u0026#34;, 8 \u0026#34;iam:DeleteAccessKey\u0026#34;, 9 \u0026#34;iam:ListAccessKeys\u0026#34;, 10 \u0026#34;iam:UpdateAccessKey\u0026#34; 11 ], 12 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;account-id\u0026gt;:user/${aws:username}\u0026#34; 13 } 14 ] 15} enable-role-assume ロールの引き受けを可能にします。管理用の作業を行う際に一時的にロールを切り替えるために使用します。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34;, 7 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;account-id\u0026gt;:role/\u0026lt;role-name\u0026gt;\u0026#34; 8 } 9 ] 10} \u0026lt;role-name\u0026gt;には引き受けを許可するロール名を指定します。ここではadminを指定します。\nMEMO ロール名にワイルドカード(*)を指定できます。ただしその場合、権限を渡しすぎている旨のワーニングが出ます。\nenable-pass-role ロールの委譲を可能にします。主にロールを必要とするサービス(EC2、Lambda、etc)に対しロールを渡すために使用します。\n1{ 2\t\u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3\t\u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: \u0026#34;iam:PassRole\u0026#34;, 7 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;account-id\u0026gt;:role/\u0026lt;role-name\u0026gt;\u0026#34; 8 } 9\t] 10} \u0026lt;role-name\u0026gt;には委譲を許可するロール名を指定します。ここではexec-lambdaを指定します。\nenable-list-roles ロールの一覧表示を可能にします。コンソール画面でロールの一覧を表示する必要がある際に使用します。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: \u0026#34;iam:ListRoles\u0026#34;, 7 \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; 8 } 9 ] 10} manage-iam IAMに関する全ての操作を行うことができる管理用のポリシーです。このポリシーは後に作成するadminロールに付与します。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: \u0026#34;iam:*\u0026#34;, 7 \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; 8 }, 9 { 10 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 11 \u0026#34;Action\u0026#34;: [ 12 \u0026#34;access-analyzer:ValidatePolicy\u0026#34;, 13 \u0026#34;access-analyzer:ListPolicyGenerations\u0026#34; 14 ], 15 \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; 16 } 17 ] 18} access-analyzerはポリシー生成をサポートしてくれる有益な情報を提供してくれるものです。 これらの権限がない場合、赤字で警告が出てくるため、とりあえず追加しておきました。\ndevelop-lambda Lambda開発に必要な権限を定義するポリシーです。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: \u0026#34;lambda:*\u0026#34;, 7 \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; 8 } 9 ] 10} develop-s3 S3開発に必要な権限を定義するポリシーです。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: [ 7 \u0026#34;s3:*\u0026#34; 8 ], 9 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::*/*\u0026#34; 10 } 11 ] 12} editable-s3-object exec-lambdaロールに付与するポリシーです。 オブジェクトのCRUDのみを可能とする必要最低限の権限を持ちます。 バケットの作成権限はないので、マネージメントコンソールから手動でバケットを作成する前提とします。\n1{ 2 \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, 3 \u0026#34;Statement\u0026#34;: [ 4 { 5 \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, 6 \u0026#34;Action\u0026#34;: [ 7 \u0026#34;s3:PutObject\u0026#34;, 8 \u0026#34;s3:GetObject\u0026#34;, 9 \u0026#34;s3:DeleteObject\u0026#34; 10 ], 11 \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::*/*\u0026#34; 12 } 13 ] 14} 以上で全てのポリシーの作成が完了しました。\nグループの作成 ユーザーはグループに所属する必要があるため先にグループを作成します。\ndeveloperグループ IAMのユーザーグループ画面から「グループを作成」をクリックします。\nユーザーグループ作成画面が表示されます。グループ名を入力します。\n画面を下にスクロールするとアタッチするポリシーの一覧が表示されます。\ndevelop-lambda develop-s3 をチェックし、画面最下部にある「グループを作成」ボタンをクリックします。\n以上の操作でグループを作成できます。\ndeveloper-baseグループ 上記と同じ操作でdeveloper-baseグループを作成します。ポリシーには\nenable-accesskey enable-list-roles enable-mfa enable-role-assume enable-role-pass を指定します。\nユーザの作成 IAMのユーザー画面から「ユーザーを追加」ボタンをクリックします。\n「ユーザー名」をdev-user、「AWSマネジメントコンソールへのユーザーアクセスを提供する」をチェックONにします。 パスワードの設定は任意の方法でOKです。今回は自動生成されたパスワードをそのまま使います。\nユーザに権限を設定する方法を選択します。 事前に検討した通り、ここではユーザをグループに所属させることにしたので「ユーザーをグループに追加」を選択します。 そして下部に表示されている二つのグループのチェックをONにして「次へ」ボタンをクリックします。\n最後に確認画面が表示されるので作成ボタンをクリックしユーザーが正常に作成できればOKです。 「.csvファイルをダウンロード」をクリックし認証情報を記載したCSVファイルを必ずダウンロードしておきます。\n作成後のdev-userが以下の状態になっていればOKです。\nロールの作成 adminロール IAMのロール画面から「ロールを作成」ボタンをクリックします。\n「信頼されたエンティティを選択」画面が表示されます。 adminロールはdev-userがロール切り替えするために使用するので、ここでは「AWSアカウント」を選択し「次へ」をクリックします。\n以降は、グループの時と同様にアタッチするポリシーを選択します。ここでは\nmanage-iam を選択します。\nexec-lambdaロール 基本的な手順はadminロールの時と同様です。ただし「信頼されたエンティティを選択」画面では、エンティティタイプとして「AWSのサービス」、ユースケースでは「Lambda」を選択します。\nアタッチするポリシーは、\neditable-s3-object を選択します。\n動作確認 これで全ての作業が完了したので動作確認を行います。\nログイン まずはルートアカウントからログアウトしdev-userでログインします。 「IAMユーザ」を選択しアカウントIDを入力して「次へ」をクリックします。\ndev-user作成時にダウンロードした認証情報のCSVに記載されているパスワードを入力し「サインイン」をクリックします。\nログインできればOKです。\nIAMを確認 dev-userはMFAの設定とアクセスキーの作成のみが行えて、それ以外は何もできないはずです。 「MFAを追加」ボタンが表示されていることが確認できました。 すでに紹介した手順なので割愛しますがルートアカウントだけではなくIAMユーザにもMFAを設定するようにしましょう。\nアクセスキーの作成ができることも確認できます。\nS3を確認 バケット一覧を表示できることが確認できました。\nLambdaを確認 関数の作成画面にて「実行ロール」にexec-lambdaを設定します。\n関数の作成後にコードを修正します。 パラメータからバケット名とオブジェクト名を取得しオブジェクトに\u0026quot;Hello, World!\u0026quot;と書き込むだけのシンプルな処理です。\n1const { S3Client, PutObjectCommand } = require(\u0026#34;@aws-sdk/client-s3\u0026#34;); 2 3exports.handler = async (event) =\u0026gt; { 4 const s3Client = new S3Client({ region: \u0026#34;ap-northeast-1\u0026#34; }); 5 const params = { 6 Bucket: event.bucketName, 7 Key: event.objectName, 8 Body: \u0026#34;Hello, World!\u0026#34;, 9 }; 10 11 try { 12 const data = await s3Client.send(new PutObjectCommand(params)); 13 console.log(\u0026#34;Success\u0026#34;, data); 14 } catch (err) { 15 console.log(\u0026#34;Error\u0026#34;, err); 16 } 17}; ローカル開発環境上で上記コードとnode_modules一式をzipに固めてからアップロードします。\n使用したサンプルコードはこちらです。\nアップロード完了後、コードが更新されていることを確認し、「Test」ボタンをクリックして実行します。\nテスト実行する際にコード内で利用しているパラメータをテストイベントとして設定します。\n実行後、S3のバケット内にオブジェクトhello.txtが作成されていれば成功です。\nロールの切り替え dev-userからadminロールに切り替えることでIAMの管理作業を実施できることを確認します。 画面右上から「ロールの切り替え」をクリックします。\n「アカウント」にアカウントID、「ロール」に\u0026quot;admin\u0026quot;、「表示名」に表示用の任意の名前を指定します。 ここではロール名と同じ\u0026quot;admin\u0026quot;と設定しました。入力後、「ロールの切り替え」ボタンをクリックします。\nadminロールに切り替えたのでIAMを操作できるはずです。IAMの画面を表示してみます。\n一例のみですが、ポリシーの一覧を表示してみました。ルートアカウントの時と同様にポリシーを編集できることが確認できます。\nおわりに 荒削りですが、AWSの権限管理の基本的な手順を紹介しました。役に立つ情報になったでしょうか？ 今回は手順を学ぶこと、そしてルートアカウントを使わずに済む状態を作ることがメインテーマであり、設定内容はかなりざっくりで行いました。\n個人的にはポリシーのActionを(ワイルドカードを使わず)きめ細かく設定するのはかなり手間なのではと感じました。 そしてポリシーの粒度はどの程度にすべきなのか悩みました。ポリシーは最大10個までしかアタッチできないので、 何でもかんでも細かく定義すればいいわけではなさそう。 その辺りの勘所は実務で運用をしてみないとなかなか掴めないのかもしれません(有識者のご意見お待ちしております)。\n","link":"https://just-plain-notes.blog/post/2023/04/understand-aws-iam/","section":"post","tags":["aws","cloud"],"title":"IAMをちゃんと使えてますか？AWSセキュリティの基本を理解しよう"},{"body":"","link":"https://just-plain-notes.blog/tags/blog/","section":"tags","tags":null,"title":"blog"},{"body":"","link":"https://just-plain-notes.blog/tags/hugo/","section":"tags","tags":null,"title":"hugo"},{"body":"Hugoのテンプレートについて Hugoで使用するテンプレート言語はHugo付属の専用テンプレート言語ではなくGo言語の標準ライブラリであるhtml/templateおよびtext/templateというライブラリが使われています。が、Hugoを使うにあたりGo言語の知識が必要になることはなさそうです(今のところは。おそらく今後もない)。\nこの記事で扱う内容 記事を書いている際に不便だなと感じたときに独自のショートコードを定義して解決できるようになることを目指します。実際に記事を執筆している段階で私が欲しいと思っていたショートコードを実装しましたのでそちらも紹介していきます。\nMEMO この記事内で実装するショートコードを実行するためにはextendedバージョンのhugoが必要です\nテンプレート記法の基本 ショートコードの実装に入る前に前提となる基本知識を押さえておきます。ショートコードはルートディレクトリ下のlayouts/shortcodesに配置します。ショートコード名.htmlという名前でファイルを作成します。例としてhello.htmlというショートコードを作成してみます。\n1\u0026lt;div style=\u0026#34;padding: 5px; border: 1px solid black;\u0026#34;\u0026gt;Hello, World!!\u0026lt;/div\u0026gt; このショートコードをマークダウン内で{{\u0026lt;hello\u0026gt;}}のように記述して使うことができます。なおショートコードの名前(ここではhello)を囲む、左右の開始と終了の3文字の記号はひと続きである必要があります。つまり、\n{{\u0026lt;hello\u0026gt;}} {{\u0026lt;　hello　\u0026gt;}} 上記の二つは正しい記述ですが、\n{{ \u0026lt;hello\u0026gt; }} こちらの記述は不正なので注意しましょう(気づかなくて少しハマりました)。\n実際に使った場合、次のように表示されます：\nHello, World!! 定義済みの変数にアクセスする テンプレートからPageオブジェクトで定義されているプロパティにアクセスしてみます。Pageオブジェクトはその名前の通りページに関する情報を保持しています。 例えばこのページのタイトルを表示してみます。hello.htmlを次のように修正します。\n1\u0026lt;div style=\u0026#34;padding: 5px; border: 1px solid black;\u0026#34;\u0026gt;Hello, {{.Page.Title}}!!\u0026lt;/div\u0026gt; 修正後に再度ショートコードを使うと、次のように表示されます：\nHello, Hugoのテンプレート(ショートコード)の使い方を整理しておく!! Pageの前についている「.」はコンテキストを表します。マークダウン内でショートコードを記述した場合、 デフォルトのコンテキストとして現在のページのコンテキストが設定されます。 コンテキストからはPageオブジェクトやSiteオブジェクトにアクセスすることができます。 またPageオブジェクトが持つParamsオブジェクトからフロントマターの情報にもアクセスできます。これらの情報にアクセスするようにさらにhello.htmlを修正してみます。\n1\u0026lt;div style=\u0026#34;padding: 5px; border: 1px solid black;\u0026#34;\u0026gt; 2 Hello, World!! 3 \u0026lt;ul\u0026gt; 4 \u0026lt;li\u0026gt;Site Title: {{ .Site.Title }}\u0026lt;/li\u0026gt; 5 \u0026lt;li\u0026gt;Page Title: {{ .Page.Title }}\u0026lt;/li\u0026gt; 6 \u0026lt;li\u0026gt;Tags: {{ .Page.Params.tags }}\u0026lt;/li\u0026gt; 7 \u0026lt;/ul\u0026gt; 8\u0026lt;/div\u0026gt; 表示してみます：\nHello, World!! Site Title: Just Plain Notes Page Title: Hugoのテンプレート(ショートコード)の使い方を整理しておく Tags: [hugo blog] コンテキストは切り替えることが可能です。例えばwithを使うことで任意のオブジェクトをコンテキストとして設定できます。また要素のコレクションをrangeでループする際は、現在対象としている要素がコンテキストに自動で設定されます。実際に確認してみます。hello.htmlを次のように修正します：\n1\u0026lt;div style=\u0026#34;padding: 5px; border: 1px solid black;\u0026#34;\u0026gt; 2 Hello, World!! 3 \u0026lt;ul\u0026gt; 4 \u0026lt;li\u0026gt;Site Title: {{ with .Site }}{{ .Title }}{{ end }}\u0026lt;/li\u0026gt; 5 \u0026lt;li\u0026gt;Page Title: {{ with .Page }}{{ .Title }}{{ end }}\u0026lt;/li\u0026gt; 6 \u0026lt;li\u0026gt;Tags: {{ range .Page.Params.tags }} {{ . }} {{ end }}\u0026lt;/li\u0026gt; 7 \u0026lt;/ul\u0026gt; 8\u0026lt;/div\u0026gt; 表示してみます：\nHello, World!! Site Title: Just Plain Notes Page Title: Hugoのテンプレート(ショートコード)の使い方を整理しておく Tags: hugo blog ひとつ前の例とほぼ同じ内容が表示されましたが、前回はTagsの配列をそのまま表示していたので、配列を表す角カッコが表示されていたのに対し、 今回のバージョンでは要素をひとつづつ取り出しながら表示しているので角カッコがなくなっているのがわかります。\nショートコードに引数を渡す これまで作成したショートコードは呼び出し時にパラメータを渡すことができなかったのでパラメータを渡せるように修正してみます。\n1\u0026lt;div style=\u0026#34;padding: 5px; border: 1px solid black;\u0026#34;\u0026gt;Hello, { .Get 0 }!!!\u0026lt;/div\u0026gt; まあ見れば意味わかるよね、って内容なので説明は割愛します。使う側では以下のようにパラメータを指定します。\n{{\u0026lt; hello \u0026quot;World\u0026quot; \u0026gt;}} 表示してみます：\nHello, World!!! 名前付きパラメータを使う 前の例でパラメータの位置番号(0)を指定していた箇所をパラメータ名に変えることで名前付きパラメータを使うことができます。以下のように修正します。\n1\u0026lt;div style=\u0026#34;padding: 5px; border: 1px solid black;\u0026#34;\u0026gt;Hello, {{ .Get \u0026#34;name\u0026#34; }}!!!!\u0026lt;/div\u0026gt; 使う側では以下のようにパラメータを指定します。\n{{\u0026lt; hello name=\u0026quot;World\u0026quot; \u0026gt;}} 表示してみます：\nHello, World!!!! MEMO 通常のパラメータと名前付きパラメータを混在して使うことはできませんでした\n実践編： 実際に使うショートコードを実装する 次のような使い方をするショートコードを実装します：{{\u0026lt; i prefix=\u0026quot;1\u0026quot; method=\u0026quot;resize\u0026quot; width=512 height=512 \u0026gt;}}\niはimageの略です。つまりこのショートコードは\u0026lt;img\u0026gt;タグを生成します。使用頻度が高いのでなるべく簡単に書けるように1文字にしました。 次の機能を持ちます。\n引数で指定したプレフィクスと一致する画像ファイルを検索する。 任意の方法(resize/crop/fill/fit)で画像を加工する。横幅と縦幅も指定できるようにする。 フォーマットを変換して画質も落とす(webpフォーマットのq50) 以降、引数の解説です。\nprefix prefixは画像ファイルパスのプレフィクスを指定します。記事と同じ階層にある複数の画像ファイルの中からプレフィクスが一致するファイルを選択し、 その画像のパスをimgタグのsrcに設定するようにします。プレフィクスが一致する画像ファイルは必ずひとつだけ存在するようにします。 画像ファイル名は必ず数字の連番で始まるようにすること、などのルールを導入すれば簡単に運用できます。\nprefixを使用する狙いとしては、\n画像ファイルのパスをフルで書くのが面倒くさいので省エネしたい 後から画像ファイル名を変更する際に記事を修正したくない を実現するためです。\nmethod ここで指定する値については正直よくわかっていないです(すみません)。 Hugoのドキュメントを参照したところ画像に対してResize/Crop/Fill/Fitという4つのメソッドが使えるみたいなので一応全て使えるように対応してみた、という感じです。\n今の私の感触としては「とりあえず画像がそれっぽく加工できていて、画像サイズが落ちていればいい」くらいにしか考えていないので深く考えないことにします。 いずれ必要な時が来たらきっと改めて調べる、ということで。\nなおChatGPTに聞いてみたら以下のような答えが返ってきました\nQ 一般的な画像処理の用語としての、Resize、Fill、Fit、Cropの違いについて簡単に説明して\nA Resize（リサイズ）：画像のサイズを変更します。これは、画像のピクセルの数を増やす（アップスケーリング）か減らす（ダウンスケーリング）操作を指します。ただし、単純なリサイズではアスペクト比（幅と高さの比率）が保持されないため、画像が引き伸ばされたり圧縮されたりする可能性があります。\nFill（フィル）：指定したサイズになるように画像をリサイズしますが、このときアスペクト比を保たずに画像の全領域が指定のサイズに合わせて伸縮します。その結果、元の画像と比べて引き伸ばされたり圧縮されたりする可能性があります。\nFit（フィット）：指定したサイズになるように画像をリサイズしますが、このときアスペクト比を保ちます。つまり、画像の短い辺が指定のサイズに一致するように画像をリサイズし、長い辺は元のアスペクト比に従ってリサイズします。\nCrop（クロップ）：画像から特定の領域を切り取ります。この操作は、画像の特定の部分を強調したり、不要な部分を取り除いたりするために使用されます。クロップ操作は、画像のアスペクト比を変更する可能性があります。\nわからない(^^;)\nwidth \u0026amp; height 数値を指定します。基本的には両方とも指定しますが、Resizeの場合どちらか片方のみを指定することも可能なようです。\nanchor CropとFillの場合に指定できる値です。\nTopLeft Top TopRight Left Center Right BottomLeft Bottom BottomRight Smart のいずれかの値を指定できるようです。正確な説明はできないですがCropで言うと切り取る領域？(何て表現するのが正しいのかわからない)を指定するものです。\n実装したコード＆解説 1\u0026lt;!-- 引数を定義 --\u0026gt; 2{{ $prefix := .Get \u0026#34;prefix\u0026#34; }} 3{{ $method := .Get \u0026#34;method\u0026#34; }} 4{{ $width := .Get \u0026#34;width\u0026#34; }} 5{{ $height := .Get \u0026#34;height\u0026#34; }} 6{{ $anchor := .Get \u0026#34;anchor\u0026#34;}} 7 8\u0026lt;!-- 引数に基づいて$sizeを設定する --\u0026gt; 9{{ $size := \u0026#34;\u0026#34; }} 10{{ if and (ne $width \u0026#34;\u0026#34;) (eq $height \u0026#34;\u0026#34;) }} 11 {{ $size = printf \u0026#34;%dx webp q50\u0026#34; $width }} 12{{ end }} 13{{ if and (eq $width \u0026#34;\u0026#34;) (ne $height \u0026#34;\u0026#34;) }} 14 {{ $size = printf \u0026#34;%dx webp q50\u0026#34; $height }} 15{{ end }} 16{{ if and (ne $width \u0026#34;\u0026#34;) (ne $height \u0026#34;\u0026#34;) }} 17 {{ $size = printf \u0026#34;%dx%d webp q50\u0026#34; $width $height }} 18{{ end }} 19{{ if (ne $anchor \u0026#34;\u0026#34;) }} 20 {{ $size = printf \u0026#34;%s %s\u0026#34; $size $anchor }} 21{{ end }} 22 23\u0026lt;!-- 検索対象ディレクトリを取得 --\u0026gt; 24{{ $paths := split .Page.File \u0026#34;/\u0026#34; }} 25{{ $dir := delimit (first (sub (len $paths) 1) $paths) \u0026#34;/\u0026#34; }} 26{{ $dir := printf \u0026#34;content/%s\u0026#34; $dir}} 27 28\u0026lt;!-- リサイズ実行後の画像オブジェクトを設定する変数 --\u0026gt; 29{{ $resized := 0 }} 30 31\u0026lt;!-- 検索対象ディレクトリ内のファイルをループする --\u0026gt; 32{{ $files := readDir $dir }} 33{{ range $files }} 34 \u0026lt;!-- 引数$prefixと先頭文字が一致するファイルの場合処理する --\u0026gt; 35 {{ if hasPrefix .Name $prefix }} 36 {{ $img := $.Page.Resources.Get .Name }} 37 \u0026lt;!-- 引数$methodで指定された値に応じて画像処理メソッドを実行する --\u0026gt; 38 {{ if eq $method \u0026#34;resize\u0026#34; }} 39 {{ $resized = $img.Resize $size }} 40 {{ end }} 41 {{ if eq $method \u0026#34;crop\u0026#34; }} 42 {{ $resized = $img.Crop $size }} 43 {{ end }} 44 {{ if eq $method \u0026#34;fill\u0026#34; }} 45 {{ $resized = $img.Fill $size }} 46 {{ end }} 47 {{ if eq $method \u0026#34;fit\u0026#34; }} 48 {{ $resized = $img.Fit $size }} 49 {{ end }} 50 \u0026lt;img src=\u0026#34;{{ $resized.RelPermalink }}\u0026#34; width=\u0026#34;{{ $resized.Width }}\u0026#34; height=\u0026#34;{{ $resized.Height }}\u0026#34;\u0026gt; 51 {{ end }} 52{{ end }} やや長いですが、事前に紹介した基本の知識だけでほぼ理解できる範囲で実装できていると思います。 条件分岐のifやその他初出の関数(readDir,split,etc)については取り上げていませんでしたが、 まあ雰囲気でわかるっしょってことで省きました。許してください。\nMEMO 入力チェックは一切行っていません。ローカルサーバを起動して確認する過程でミスに気づけるため省きました。\n以下、いくつか解説した方が良いポイントだけ解説しておきます。\nrangeループ周りの処理 rangeループの中で指定している.Nameは、range $filesで個々のファイルオブジェクトが、ループ毎にコンテキストに設定されているので、 つまりファイルオブジェクツのName属性を取得している、という意味になります。\nまた、rangeループの中で$.Pageという記述が出てきますが、これはrangeループのコンテキストがファイルオブジェクトになっているため、 これまでの.Pageという記述ではページオブジェクトにアクセスできなくなるためです。その場合は$.Pageのように最上位からたどることができます。\n検索対象ディレクトリを取得する部分 .Page.Fileで記事ファイルのパスを取得しています。このパスの値はpost/...から始まるパスになっていました。 readDirに指定する相対パスがどこを基準にするのか、についてですが、これはプロジェクトルートからのようです。 つまりreadDirに渡す値としてはcontent/post/...となるようにする必要があるため、そのように加工をしています。\n画像処理後の画像オブジェクト$resizedの初期値 引数$methodの内容に基づいて画像処理を行うため、if文の外でローカル変数$resizedを宣言していますが、これの初期値を0にしています。 本来であればnilのような値を指定したいですが、そのような値はテンプレート言語には存在しないようです。\nそのような理由でとりあえず(数値でも文字列でも)なんでもよいから0を指定しました。静的型言語的に考えると数値が設定されたりオブジェクトが設定されたりして気持ち悪いのですが、これは仕方がなさそう。\n動作確認 実装したショートコードを実際に使用して動作を見てみます。以下の画像をサンプル画像として使用しました。\nサイズ: 1.3MB フォーマット: jpg 解像度: 1920x1280 横幅を640pxでリサイズ {{\u0026lt; i prefix=\u0026quot;1\u0026quot; method=\u0026quot;resize\u0026quot; width=640 \u0026gt;}}\nサイズ: 7KB フォーマット: webp 解像度: 640x427 え、7KB！？こんなに小さくなるんですね・・・びっくり。明らかに画質は下がってますね。\nCropで切り抜く(Centerから500x500) {{\u0026lt; i prefix=\u0026quot;1\u0026quot; method=\u0026quot;crop\u0026quot; width=500 height=500 anchor=\u0026quot;Center\u0026quot; \u0026gt;}}\ncenter(女性の手首あたり？)から500x500で切り抜かれている感じがするから正しく動いている・・・かな？多分。\nCropで切り抜く(TopRightから800x800) {{\u0026lt; i prefix=\u0026quot;1\u0026quot; method=\u0026quot;crop\u0026quot; width=800 height=800 anchor=\u0026quot;TopRight\u0026quot; \u0026gt;}}\nなんとなくできている感じがします。おわり。\n","link":"https://just-plain-notes.blog/post/2023/04/understand-hugo-template/","section":"post","tags":["hugo","blog"],"title":"Hugoのテンプレート(ショートコード)の使い方を整理しておく"},{"body":"もう何度挫折したか数えきれないですが懲りずにブログを始めます。アウトプットできる人間になりたいという思いをどうしても捨てきれないということ、そして最近のブームに乗っかってAIの力を借りることができれば文章が下手くそな自分でもそこそこ戦えるんじゃないかなと目論んだからです。主に技術系の記事を書いていきます。よろしくお願いします。\n","link":"https://just-plain-notes.blog/post/2023/04/start-blog/","section":"post","tags":["blog"],"title":"ブログをはじめることにしました"},{"body":"","link":"https://just-plain-notes.blog/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://just-plain-notes.blog/series/","section":"series","tags":null,"title":"Series"}]